<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>CS 184 Rasterizer</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="font-sans">
    <div class="bg-zinc-100 p-10">
        <div class="text-3xl font-black">
            CS 184: Computer Graphics and Imaging, Spring 2023
        </div>
        <div class="text-2xl font-bold text-red-500">
            Project 1: Rasterizer
        </div>
        <div class="text-1xl text-slate-600 font-semibold">
            Eloy Ye Luo and Esther Cai, CS184-nil
        </div>
    </div>
    <div class="m-8 flex flex-col items-center	">
        <div class="mt-3 bg-zinc-100 p-5 rounded-lg max-w-2xl	">
            <div class="text-1xl font-bold">
                The project write-up is hosted at <a href="https://eloyye.github.io/cs184Project1Docs/" class="text-rose-500">https://eloyye.github.io/cs184Project1Docs/</a>
            </div>

        </div>
    <div class="mt-8 bg-zinc-100 p-5 rounded-lg lg:flex lg:flex-row justify-between gap-10 md:flex-col max-w-6xl">
        <div class="text-3xl font-bold">
            Overview
        </div>
            This project provides a hands-on foundation on rendering objects onto the screen. To do this, we have
        implemented a simple triangle rasterization which will convert three vertices which make up a triangle and
        fill the inside with specified color. This algorithm is not perfect as it does not address the problem of
        aliasing and reduce artifacts. For this reason, we have implemented supersampling which first samples the
        triangle at a high resolution and then downsample in order to reduce aliasing by blurring. The third task we
        implemented transforms for translation, scaling, and rotation which are basic primitives that allows things
        like perspective camera, animation, etc. The fourth is rasterizing a triangle by interpolating the pixels inside
        the triangle through barycentric interpolation of three given points. The application of barycentric interpolation
        is important for the mapping between pixel space and the texture space in the fifth task where we implemented
        pixel sampling for texture mapping. Then the textures are sampled in either the nearest texel or interpolated
        called bilinear interpolation. It is optimal to try and save as much space as possible, so level mipmapping are
        an solution that tries to be efficient in reducing memory usage. One of the most frustrating parts about the
        implementation of these tasks is deubgging as most of the results rely on eyeballing the output of the canvas.

    </div>

    <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-6xl">
        <div class="text-3xl font-bold mb-3">
            Section I: Rasterization
        </div>
        <div class="">
            <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                <img src="public/images/section1test6.png" class="rounded-lg max-w-lg max-h-lg lg:max-w-sm">
                <div class="max-w-lg">
                    This is from a build and a result of the rasterization of triangles.
                    Here, we can see in the PixelTool that there exists some aliasing, jaggies in fact, when sampling.
                </div>
            </div>
            <p class="text-xl">
                To rasterize a simple triangle from three given 2-dimensional vertices,
                we first need to find the triangle's bounding box such that we can sample the required domain rather than the
                entire framebuffer. This is done by taking the minimum x and y values as a starting point and floor it to map it
                in the framebuffer, and then sample until we reach the maximum x and y values. This means that we are not checking anything that
                goes beyond the triangle's bounds. Then once we sample for each point in the bounding box, each point (adjusted to the center
                by adding an offset of 0.5 to both x and y points) are then tested whether or not they lie inside the triangle via
                the three line test. If the point passes the three-line test, then we fill the pixel.
            </p>
        </div>

    </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-6xl">
            <div class="text-3xl font-bold mb-3">
                Section II: Antialiasing by Supersampling
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
<!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-6xl">
            <div class="text-3xl font-bold mb-3">
                Section III: Transforms
            </div>
            <div class="flex flex-col items-center">
                <img src="public/images/section2.png" alt="cubeman jump" class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 mr-5">
                <p class="text-xl">
                    This section is about the implementation of transform operations:
                    translate, scale, and rotate. In my cubeman, I have essentially changed the head, the arms,
                    and the legs to match a human skin. I have also changed the pants to a jeans color.
                    What cubeman is doing is just his girly jump pose with his right arm raised and his left
                    arm straight. His arms were raised by rotating about 90 degrees and then readjusting the
                    translation of the arm. On the other hand the entire legs were rotated and the lower legs
                    were rotated more. Interesting to note that the transforms are conducted in
                    hierachies so even though the upper and lower legs are separate components,
                    they can nevertheless be transformed.
                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-6xl">
            <div class="text-3xl font-bold mb-3">
                Section IV: Barycentric coordinates
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                    <!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-6xl">
            <div class="text-3xl font-bold mb-3">
                Section V: "Pixel sampling" for texture mapping
            </div>
            <div class="">
                <div class="grid grid-cols-2 grid-rows-2 gap-5 mb-5">
                    <div class="p-5 bg-slate-100 rounded-lg">
                        <img src="public/images/pixelNearest1.png" alt="pixel nearest 1x ss" class="rounded-lg">
                        <p class="mt-2 text-sm">
                            This is the Nearest Neighbor Pixel Sampling method with 1 sample per pixel. IN this
                            sampling method, artifacts and aliasing are most prominent. You can observe that the latitude
                            and longtitude markings are all cutoff.
                        </p>
                    </div>
                    <div class="p-5 bg-slate-100 rounded-lg">
                        <img src="public/images/pixelNearest16.png" alt="pixel nearest 16x ss" class="rounded-lg">
                        <p class="mt-2 text-sm">
                            This is the Nearest Neighbor Pixel Sampling method with 16 sample per pixel. In this
                            sampling method, artifacts and aliasing are pretty much non-existent due to applied
                            antialiasing.
                        </p>
                    </div>
                    <div class="p-5 bg-slate-100 rounded-lg">
                        <img src="public/images/pixelBilinear1.png" alt="pixel bilinear 1x ss" class="rounded-lg">
                        <p class="mt-2 text-sm">
                            This is the bilinear Pixel Sampling method. This sampling method is yields less visible artifacts than the Nearest neighbor pixel sampling
                            at 1 sample per pixel. The level of fidelity and detail is somewhat on par with the top right sampling method.
                        </p>
                    </div>
                    <div class="p-5 bg-slate-100 rounded-lg">
                        <img src="public/images/pixelBilinear16.png" alt="pixel bilinear 16x ss" class="rounded-lg">
                        <p class="mt-2 text-sm">
                            This is the Bilinear Sampling method with 16 sample per pixel. In this
                            sampling method, artifacts and aliasing are reduced to a minimum and there is a
                            slight difference in that it is more blurred than the bilinear 1 sample per pixel sampling
                            method.
                        </p>
                    </div>
                </div>
                <div class="p-5 bg-slate-100 rounded-lg mb-5">
                    For 1 sample per pixel, i.e no supersampling, then we can see that bilinear filtering is clear winner
                    and the biggest difference between the two pixel sampling method because in the case of nearest neighbors,
                    we are still sampling too much to the point where artifacts and aliasing still occurs. For bilinear
                    filtering, it is similar to applying a box filter in that the process of interpolating reduces high
                    frequency signals in sampling the texture.
                </div>
                <h1 class="font-semibold text-2xl">
                    What is Pixel Sampling?
                </h1>
                <p>
                    Pixel Sampling is essentially rendering an object and have its pixels correspond to a
                    texture image that is then embedded to the object which gets displayed.
                </p>
                <h1 class="font-semibold text-xl">
                    Implementation
                </h1>
                <p>
                    Our task is to implement pixel texture sampling of a triangle. The function is almost
                    identical to part 2 supersampling triangle except for the fact that we are not taking
                    a single uniform color, but rather pixel sample at every valid point in the triangle. The pixel
                    sampling method is either <span class="italic">nearest neighbors</span> or <span class="italic">bilinear</span>
                    and more will be discussed below. However to pixel sample corresponding to a texture image, we must
                    first transform the points on the triangle in model space to UV texture space. This procedure is done
                    by doing a barycentric interpolation on the vertices of the triangle in uv-space. In the sampling
                    procedure, a level-0 mipmap is used containing the full width and the height of the texture and
                    each u and v point is scaled by the mipmap width and height respectively. This allows access to the
                    corresponding texels which returns the pixel values and is the output of the sampling method.
                </p>
                <h1 class="font-semibold text-xl">
                    Pixel Sampling Methods
                </h1>
                <ol class="list-decimal ml-4">
                    <li>
                        <span class="font-bold">Nearest Neighbor Pixel Sampling</span>: Sampling based on the mipmap-0,
                        width-and-height-scaled uv values corresponding the closest existing texel value in texture sample space.
                    </li>
                    <li>
                        <span class="font-bold">Bilinear Pixel Sampling</span>: On the other hand, bilinear sampling is
                        essentially avoiding picking a hard value in the texture sample space and instead interpolates
                        on the colors of the 4 closest texels of <span class="font-bold">width-and-height scaled</span> (WH) uv point. This process of
                        interpolation usually revolves around the using successive linear interpolations as described in
                        lecture. But for my implementation, it is closely similar to the barycentric interpolation but
                        instead interpolating on four nearest points of the WH uv point. It is still valid
                        because the aforementioned four vertices are convex and thus has a similar property as the
                        barycentric interpolation.
                    </li>
                </ol>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-6xl">
            <div class="text-3xl font-bold mb-3">
                Section VI: "Level sampling" with mipmaps for texture mapping
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                    <!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>


    </div>
</body>
</html>
