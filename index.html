<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>CS 184 Rasterizer</title>
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />
    <script src="https://cdn.tailwindcss.com"></script>
</head>

<body class="font-sans">
    <div class="bg-zinc-100 p-10">
        <div class="text-3xl font-black">
            CS 184: Computer Graphics and Imaging, Spring 2023
        </div>
        <div class="text-2xl font-bold text-red-500">
            Project 1: Rasterizer
        </div>
        <div class="text-1xl text-slate-600 font-semibold">
            Eloy Ye Luo and Esther Cai, CS184-nil
        </div>
    </div>
    <div class="m-8 flex flex-col items-center	">
        <div class="mt-3 bg-zinc-100 p-5 rounded-lg max-w-2xl	">
            <div class="text-1xl font-bold">
                The project write-up is hosted at <a href="https://eloyye.github.io/cs184Project1Docs/" class="text-rose-500">https://eloyye.github.io/cs184Project1Docs/</a>
            </div>

        </div>
    <div class="mt-8 bg-zinc-100 p-5 rounded-lg lg:flex lg:flex-row justify-between gap-10 md:flex-col max-w-5xl">
        <div class="text-3xl font-bold">
            Overview
        </div>
            This project provides a hands-on foundation on rendering objects onto the screen. To do this, we have
        implemented a simple triangle rasterization which will convert three vertices which make up a triangle and
        fill the inside with specified color. This algorithm is not perfect as it does not address the problem of
        aliasing and reduce artifacts. For this reason, we have implemented supersampling which first samples the
        triangle at a high resolution and then downsample in order to reduce aliasing by blurring. The third task we
        implemented transforms for translation, scaling, and rotation which are basic primitives that allows things
        like perspective camera, animation, etc. The fourth is rasterizing a triangle by interpolating the pixels inside
        the triangle through barymetric interpolation of three given points. The application of barycentric interpolation
        is important for the mapping between pixel space and the texture space in the fifth task where we implemented
        pixel sampling for texture mapping. Then the textures are sampled in either the nearest texel or interpolated
        called bilinear interpolation. It is optimal to try and save as much space as possible, so level mipmapping are
        an solution that tries to be efficient in reducing memory usage. One of the most frustrating parts about the
        implementation of these tasks is deubgging as most of the results rely on eyeballing the output of the canvas.

    </div>

    <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-5xl">
        <div class="text-3xl font-bold mb-3">
            Section I: Rasterization
        </div>
        <div class="">
            <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                <img src="public/images/section1test6.png" class="rounded-lg max-w-lg max-h-lg lg:max-w-sm">
                <div class="max-w-lg">
                    This is from a build and a result of the rasterization of triangles.
                    Here, we can see in the PixelTool that there exists some aliasing, jaggies in fact, when sampling.
                </div>
            </div>
            <p class="text-xl">
                To rasterize a simple triangle from three given 2-dimensional vertices,
                we first need to find the triangle's bounding box such that we can sample the required domain rather than the
                entire framebuffer. This is done by taking the minimum x and y values as a starting point and floor it to map it
                in the framebuffer, and then sample until we reach the maximum x and y values. This means that we are not checking anything that
                goes beyond the triangle's bounds. Then once we sample for each point in the bounding box, each point (adjusted to the center
                by adding an offset of 0.5 to both x and y points) are then tested whether or not they lie inside the triangle via
                the three line test. If the point passes the three-line test, then we fill the pixel.
            </p>
        </div>

    </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-5xl">
            <div class="text-3xl font-bold mb-3">
                Section II: Antialiasing by Supersampling
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
<!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-5xl">
            <div class="text-3xl font-bold mb-3">
                Section III: Transforms
            </div>
            <div class="flex flex-col items-center">
                <img src="public/images/section2.png" alt="cubeman jump" class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 mr-5 max-w-lg">
                <p class="text-xl">
                    This section is about the implementation of transform operations:
                    translate, scale, and rotate. In my cubeman, I have essentially changed the head, the arms,
                    and the legs to match a human skin. I have also changed the pants to a jeans color.
                    What cubeman is doing is just his girly jump pose with his right arm raised and his left
                    arm straight. His arms were raised by rotating about 90 degrees and then readjusting the
                    translation of the arm. On the other hand the entire legs were rotated and the lower legs
                    were rotated more. Interesting to note that the transforms are conducted in
                    hierachies so even though the upper and lower legs are separate components,
                    they can nevertheless be transformed.
                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-5xl">
            <div class="text-3xl font-bold mb-3">
                Section IV: Barycentric coordinates
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                    <!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-5xl">
            <div class="text-3xl font-bold mb-3">
                Section V: "Pixel sampling" for texture mapping
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                    <!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>

        <div class="mt-10 bg-slate-300 p-5 rounded-lg max-w-5xl">
            <div class="text-3xl font-bold mb-3">
                Section VI: "Level sampling" with mipmaps for texture mapping
            </div>
            <div class="">
                <div class="mt-5 mb-5 bg-slate-100 p-5 rounded flex flex-col items-center gap-5 float-left mr-5 max-w-lg">
                    <!--                    img-->
                </div>
                <p class="text-xl">

                </p>
            </div>
        </div>


    </div>
</body>
</html>
